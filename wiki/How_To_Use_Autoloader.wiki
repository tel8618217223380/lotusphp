#labels 文档
= 系统需求 =
 # 只支持php 5（lotusphp所有组件都要求php5环境）
 # 不要求Web服务器，可运行于命令行下

= 用法 =
== 运行lotus自带的例子 ==
 # 在[http://code.google.com/p/lotusphp/downloads/list?q=Autoloader]下载最新版本，解压后放到任意目录（如果想通过Web访问，请放到相应的网站目录）
 # 运行example\Autoloader\simplest\index.php，通过Web访问[http://localhost/lotusphp/example/Autoloader/simplest/index.php]，或者通过命令行访问都可以
 # 屏幕上打印“Hello”说明运行成功
 * 看一下simplest/index.php和HelloWorld.php的源码能帮助你理解这个示例，他们非常简单，还有中文注释

== 示例1：最简单的用法 ==
{{{
<?php
$lotusHome = dirname(dirname(dirname(dirname(__FILE__))));
//获取lotusphp所在的路径
include $lotusHome . "/runtime/Autoloader/Autoloader.php";
//加载Autoloader类文件

/*
 * 初始化Autoloader类
 * 将example/Autoloader/simplest/Classes Will Be Autoloaded目录加到“自动加载目录列表中”
 */
$autoloader = new LtAutoloader;
//初始化Autoloader类
$directories = array("./Classes Will Be Autoloaded/");
//指定需要自动加载的目录,array里的也可以换成您想自动加载的目录,也可以指定多个目录,例子中的目录为example/Autoloader/simplest/Classes Will Be Autoloaded
$autoloader->init($autoloader->scanDir($directories));
//这里就开始自动加载您刚指定目录中的以.php,.inc结尾的文件
//注：下面的类看上去没有定义，其实系统就会寻找有没有自动加载的函数,在Lotus Autoloader里自动加载的函数实际是LtAutoloader->loadClass()。 

/*
 * 初始化Autoloader类
 */

/*
 * 初始化完成，开始享受Autoloader的便利
 * 之前你并没有手工include/require HelloWorld.php文件
 * 当你new HelloWorld()的时候，Autoloader便会为你自动把HelloWorld.php包含进来
 */
$hello = new HelloWorld();
$hello->sayHello();
}}}
== 示例2：在生产环境获取更好的性能 ==
== 示例3：和lotusphp框架的其它组件一起工作 ==

= 延伸阅读：我们为什么要做Autoloader =
黑话解释： *类库文件* 本文档中所说的类库文件是指被包含（include/require）的公共文件，他们通常定义一些class, function

== 传统include/require的不足 ==
在没用Autoloader的时候，怎样加载类库文件？最容易想到的是用include/require来包含类库文件，这种文件包含通常会有如下问题：

 # *目录名和文件名变化引起程序代码变化* 当类库文件目录名或者文件名需要更改的时候，所有include了这个文件的php文件也要随着修改，这加大了源代码目录结构重构的负担。Windows和Linux对文件路径大小写和目录分隔符（斜线和反斜线）的处理不同，也使得PHP程序员需要花费相当一部分精力来应对文件名和文件路径问题。
 # *相对路径的性能问题* 我们不会把类库文件的绝对路径写死在代码里，于是采用相对路径，一种做法是设置php.ini和include_path值，然后给include()传入一个相对路径，Zend Framework和雅虎就是这样做的，这种方案存在显而易见的性能问题，include_path的值越多，性能损失就越大。php引擎处理include_path的机制参见[http://www.php.net/manual/en/ini.core.php#ini.include-path]。包含文件时使用绝对路径也能让APC，eAccelerator等Opcode Cache更有效地缓存他们。另一种流行的方法是利用__FILE__魔术变量取得应用的根路径，include的时候使用基于“应用的根路径”的绝对路径,如include($appRoot . "conf/db.php")，这个方法很好的解决了相对路径带来的性能问题，CakePHP，Symfony等就是用的这种方案。
 # *类库文件间相互依赖的问题* 类库文件之间存在依赖，为了保证运行时不出现“类定义找不到”的情况，类库文件会用将需要的更基础的类库包含进来，又为了保证不重复包含，通常要用include_once/require_once，Zend Framework就是这样做的。include_once比include慢。

当团队里不同水平，不同喜好的成员共同维护一份代码时，这些问题尤其严重。

== Lotus Autoloader如何解决这些问题 ==
为了解决上面这些问题，我在kiwiphp/lotusphp中加入了autoloader。Lotus Autoloader是这样解决上述问题的：
 # Autoloader会动态扫描需要自动加载的类库目录，生成array("类名" => "文件")数组，用了Autoloader的程序，完全不需要写include/require来加载类库，代码里不会出现类库文件的路径、文件名。
 # 由于代码里已经不需要写类库文件的路径了，自然也不存在相对路径的问题。
 # php5的autoload()机制会解决这个依赖的问题，详细情况参见：http://php.net/manual/en/language.oop5.autoload.php

== 和其它Autoloader有什么不同 ==
 # Zend Framework和QeePHP的Autoloader机制是通过类名翻译出文件路径，而Lotus Autoloader是查找一个 array("类名" => "文件")数组，原因是我们（Lotusphp开发者）希望类名不要跟文件路径耦合，这样PHP程序员写程序时不必关注类的路径，只要名字写对了，就可以加载，重构的时候调整了类文件的目录或者名字，也不影响调用他的程序；另一个好处是这种方案兼容性较好，Zend Framework的组件也能被Lotus Autoloader自动加载。而Zend Framework和Qee则希望基于他们建立的应用程序命名更规范。
 # 当然这种Autoload机制导致类库的class名字不能重复，在多年的实践中，我们发现，与“类名不要跟文件路径耦合”这个问题比起来，类名唯一引起的痛苦要小得多。

== 常见问题 ==
 # Q:类名是不是必须得唯一?如果重名怎么办?<br>A:类名必须唯一,如果重名会被覆盖
 # Q:Autoloader会不会把所有的class都加载进来?<br>A:不会,只有在new HelloWorld()的时候,才把HelloWorld所在的文件include进来,绝对的按需加载!
 # Q:怎么在Lotus里没看到__autoload()函数?<br>A:Lotus Autoloader自动加载的函数实际是LtAutoloader->loadClass(),spl_autoload_register(array($this, "loadClass"));这个语句等于是告诉 php引擎:当你找__autoload()的时候,就直接去找LtAutoloader->loadClass()吧.通过spl_autoload_register注册了自己的函数，PHP就不会调用__autoload()函数，而会调用自定义的函数,也就是loadClass

= 鸣谢 =
 # Autoload的理念来自Symfony，我是用Symfony做应用的时候享受Autoload的好处才在kiwiphp中加入Autoloader的。
 # QeePHP的作者dualface等人让我知道了PHP5的autoload()机制，我才放弃了原本那个笨拙的办法：把所有类库打包成一个大文件，然后包含进来，我还为这个打包机制设计了黑白名单。详细讨论过程参见：http://www.phpchina.com/bbs/viewthread.php?tid=142775
 # PHPChina的nightsailer提供的"class -> file" mapping方案跟我最终采用的方案完全一样，刚开始我没看懂他的回复，等我自以为想到一个最合适的方案时，才发现之前nightsailer已经说过了：）